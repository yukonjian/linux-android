#、##、__VA_ARGS__和##__VA_ARGS__的作用
/*参考文档*/
https://blog.csdn.net/q2519008/article/details/80934815

1. # 用来把参数转换成字符串
#define P(A) printf("%s:%d\n",#A,A);
P(a+b); out: a+b:3
#define SQUARE(x) printf("The square of "#x" is %d.\n", ((x)*(x)));

2. ## 运算符可以用于宏函数的替换部分。这个运算符把两个语言符号组合成单个语言符号，
为宏扩展提供了一种连接实际变元的手段
#define XNAME(n) x ## n
如果这样使用宏：XNAME(8)
则会被展开成这样：x8

注：
##就是个粘合剂，将前后两部分粘合起来，也就是有“字符化”的意思。但是“##”不能随意粘合任意字符，
必须是合法的C语言标示符。在单一的宏定义中，最多可以出现一次“#”或“##”预处理操作符。
如果没有指定与“#”或“##”预处理操作符相关的计算次序，则会产生问题。
为避免该问题，在单一的宏定义中只能使用其中一种操作符(即，一份“#”或一个“##”，或都不用)。
除非非常有必要，否则尽量不要使用“#”和“##”。

3. __VA_ARGS__ 是一个可变参数的宏
实现思想就是宏定义中参数列表的最后一个参数为省略号（也就是三个点）。
#define TLV_ITEM(type, ...) \
	(type), TLV_LENGTH(__VA_ARGS__), __VA_ARGS__

4. ##__VA_ARGS__  宏前面加上##的作用在于，当可变参数的个数为0时，这里的##起到把前面多余的","去掉的作用,否则会编译出错
#define my_print(fmt,...)  printf(fmt,##__VA_ARGS__)
若使用__VA_ARGS__则，my_print("compile"); 会编译失败
