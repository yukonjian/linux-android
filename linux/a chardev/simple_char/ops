一、读写涉及的操作
1. 关于驱动中读写函数返回值和应用读写函数返回值的对比。
当驱动中的返回值>=0;则应用程序的返回值等于驱动的返回值。
当驱动中的返回值<0; 则应用程序的返回值等于 -1；

2. 在读写函数中 loff_t *offset 的值会在函数退出时，赋值给filp->f_pos;
   故在读写函数中操作filp->f_pos将没有效果。
3. int access_ok(int type, const void *addr, unsigned long size);
type：VERIFY_READ（读）或VERIFY_WRITE（读写）；
addr:参数为用户空间地址，
size: 为字节数，可使用sizeof()。
return : 1是成功 (存取没问题) 和0是失败 (存取有问题)。
用途：access_ok不做校验内存存取的完整工作；它只检查内存引用是否在这个进程有合理权限的内存范围中，且确保这个地址不指向内核空间内存。

4. 内核空间和用户空间的数据拷贝,会进行地址检测, may sleep
unsigned long copy_from_user(void *to, const void __user *from, unsigned long n)
unsigned long copy_to_user(void __user *to, const void *from, unsigned long n)

return： number of bytes that could not be copied. On success, this will be zero.
If some data could not be copied, this function will pad the copied data to the requested size using zero bytes.

put_user ( x, ptr);
get_user ( x, ptr);
x : 定义的变量，长度为 1，2，4，8
ptr : 用户空间的指针
Returns zero on success, or -EFAULT on error.

5. int snprintf(char *str, size_t size, const char *format, ...)
   int sscanf(const char *buffer, const char *format, ...)

6. echo 进行写操作，会将echo输入的字符串放入write函数的buf中，count为字符串的长度。
   当write函数的返回值retval小于count,则还会再一次调用write函数,带人写函数中buf = buf + retval; count = count - retval;
   执行过程为：打开--写（写）--关闭
   cat 进行读操作，cat会一直调用读函数，直到其返回0才停止。

7. seek的几个宏
#define SEEK_SET	0	/* seek relative to beginning of file */
#define SEEK_CUR	1	/* seek relative to current file position */
#define SEEK_END	2	/* seek relative to end of file */
